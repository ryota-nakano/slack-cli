# GitHub Copilot 開発ガイドライン

## 🎯 基本方針

このプロジェクトでは**効率的で正確な問題解決**を重視します。

## 🔍 デバッグファーストアプローチ

問題が報告されたら、推測ではなく**実際のデータ**で原因を特定します。

### 手順

1. **問題報告を受けたら**
   - すぐに修正しない
   - まずデバッグ情報を収集する
   - 必要に応じてデバッグログの実行をお願いする

2. **ログ分析**
   - 実際の動作を確認
   - 変数の値を追跡
   - 処理の流れを把握
   - 根本原因を特定

3. **最小限の修正**
   - 特定した原因だけを修正
   - 不要な変更はしない
   - テストで動作確認

4. **クリーンアップ**
   - デバッグコードを削除
   - コメントを整理
   - コミット

### デバッグ手法

```javascript
// 問題箇所に一時的なデバッグログを追加
if (process.env.DEBUG_FEATURE) {
  console.error(`[DEBUG] 変数名: ${変数}`);
  console.error(`[DEBUG] 状態: ${JSON.stringify(状態)}`);
}
```

実行時:
```bash
DEBUG_FEATURE=1 npm start
```

## ⚠️ やってはいけないこと

- ❌ 推測だけで修正する
- ❌ 複数箇所を同時に変更する
- ❌ デバッグせずに「多分これが原因」と判断する
- ❌ 動作確認せずにコミットする

## ✅ やるべきこと

- ✅ デバッグログで実際の動作を確認
- ✅ 原因を特定してから修正
- ✅ 最小限の変更で問題を解決
- ✅ テストで動作確認
- ✅ デバッグコードを削除してクリーンアップ

## 🎓 教訓

### 今回の学び（v2.2.x系バグ修正より）

**問題**: Ctrl+J改行で行が増殖する

**悪い対応**:
```javascript
// 推測で色々変更
// → 何度も修正が必要になった
```

**良い対応**:
```javascript
// デバッグログで実際の値を確認
if (process.env.DEBUG_READLINE) {
  console.error(`[DEBUG] screenCursorLine: ${this.screenCursorLine}`);
  console.error(`[DEBUG] currentLineIdx: ${currentLineIdx}`);
}
// → 一発で根本原因を特定できた
```

**結果**: デバッグログで`screenCursorLine`が更新されていないことが判明 → 1箇所の修正で完璧に動作

## 📋 チェックリスト

問題修正時は以下を確認:

- [ ] デバッグログで実際の動作を確認したか？
- [ ] 根本原因を特定したか？
- [ ] 最小限の変更で修正したか？
- [ ] テストで動作確認したか？
- [ ] デバッグコードを削除したか？
- [ ] 関連ドキュメントを更新したか？

## 📚 ドキュメント更新の重要性

**機能追加・更新・バグ修正を行った際は、必ず関連ドキュメントを更新する**

### 更新が必要なドキュメント

1. **README.md**
   - 新機能の説明を追加
   - コマンド一覧を更新
   - 使い方・キーボードショートカットを更新
   - 特徴セクションに新機能を追加

2. **CHANGELOG.md**
   - バージョン番号と日付を記載
   - 新機能（✨）、バグ修正（🐛）、改善（📝）を明確に分類
   - ユーザーに影響する変更を分かりやすく記述

3. **ヘルプテキスト（src/utils/help.js）**
   - 新コマンドを追加
   - コマンドの説明を更新

4. **その他のドキュメント**
   - QUICKSTART.md（該当する場合）
   - ARCHITECTURE.md（アーキテクチャ変更の場合）

### ドキュメント更新のタイミング

1. **コード変更と同時にコミット**
   - 機能実装 → ドキュメント更新 → 一緒にコミット
   - または、機能実装後すぐに別コミットでドキュメント更新

2. **リリース前に必ず確認**
   - バージョンタグを付ける前にドキュメントが最新か確認
   - CHANGELOGに今回のリリース内容が記載されているか確認

3. **ユーザー視点で記述**
   - 技術的な詳細より、ユーザーへの影響を重視
   - 実際の使用例を含める
   - 簡潔で分かりやすい説明を心がける

### 例：機能追加時の流れ

```bash
# 1. 機能を実装
git commit -m "feat: 新機能を追加"

# 2. ドキュメントを更新
# - README.mdに使い方を追加
# - CHANGELOG.mdに変更履歴を追加
# - help.jsにコマンドを追加

git commit -m "docs: 新機能のドキュメントを追加"

# 3. バージョンアップ
# - package.jsonのバージョンを更新
git commit -m "chore: bump version to x.y.z"

# 4. プッシュとタグ
git push origin main
git tag -a vx.y.z -m "vx.y.z - 変更内容の要約"
git push origin vx.y.z
```

### ⚠️ ドキュメント更新を忘れると...

- ❌ ユーザーが新機能を知らない
- ❌ 使い方が分からない
- ❌ バグ修正されたことに気づかない
- ❌ プロジェクトの信頼性が低下

### ✅ ドキュメントが最新だと...

- ✅ ユーザーがすぐに新機能を使える
- ✅ サポート問い合わせが減る
- ✅ プロジェクトが信頼される
- ✅ 将来の自分も助かる

## 🚀 効率化のポイント

1. **早期のデバッグ**: 最初にデバッグ → 時間短縮
2. **データ駆動**: 推測より実データ → 正確
3. **最小変更**: 必要最小限の修正 → 安全
4. **段階的確認**: 修正後すぐテスト → 早期発見

## 💡 まとめ

**「デバッグファーストで効率的に問題解決！」**

- 推測ではなく実データで判断
- 最小限の変更で正確に修正
- テストとクリーンアップを忘れずに

このアプローチで、品質の高いコードを効率的に開発できます。

## 🤖 カスタムエージェント

### Release Agent（リリースエージェント）

**説明**: バージョンアップ、コミット、プッシュ、タグ付けを自動実行するエージェント

**トリガーフレーズ**:
- 'リリースして'
- 'タグをつけて'
- 'バージョンアップして'
- 'プッシュしてタグをつけて'
- 'release'
- 'デプロイして'

**実行内容**:
1. 現在のバージョンを確認
2. バージョンタイプ（patch/minor/major）をユーザーに確認
3. `npm version <type>` でバージョンアップ
4. 変更をコミット
5. GitHubにプッシュ
6. タグを作成してプッシュ
7. CHANGELOGの更新を確認・提案

**使用例**:
- ユーザー: 「バグ修正したからリリースして」 → patch バージョンアップ実行
- ユーザー: 「新機能追加したからタグをつけて」 → minor バージョンアップ実行
- ユーザー: 「v2.22.0でリリースして」 → 指定バージョンでリリース実行
