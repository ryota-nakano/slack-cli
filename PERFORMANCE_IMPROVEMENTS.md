# 起動速度改善提案

## 現状分析

現在の起動時間: **約0.3秒** (すでに高速)

起動フロー:
1. 設定ファイルの読み込み
2. チャンネル選択画面の初期化
   - 履歴の取得 (ローカル、高速)
   - **リアクションの取得 (API呼び出し、遅い可能性)**
   - 履歴の表示

## ボトルネック

### 1. リアクション取得のAPI呼び出し
**場所**: `src/commands/thread.js` の `channelChat()` 関数
```javascript
const reactions = await client.getReactions(API.REACTION_FETCH_LIMIT, 'eyes');
```

**問題点**:
- 起動時に毎回Slack APIを呼び出す
- ネットワーク遅延が起動時間に直接影響
- リアクションが多い場合、レスポンスが遅くなる

## 改善提案

### 提案1: リアクション取得の並列化 (推奨度: ★★★★★)

**実装難易度**: 低
**効果**: 中〜高
**リスク**: 低

履歴表示とリアクション取得を並列実行し、リアクションは取得後に追加表示する。

**実装方法**:
```javascript
async function channelChat() {
  console.log(chalk.cyan('📋 チャンネルを選択してください\n'));
  
  // 履歴をすぐに表示
  const history = historyManager.getTodayHistory();
  if (history.length > 0) {
    await displayGroupedHistory(history, client, historyManager);
    console.log(chalk.gray('\n💡 ヒント: /数字 で履歴から開く（例: /1）\n'));
  }
  
  // リアクション取得を非同期で開始（待たない）
  const reactionsPromise = client.getReactions(API.REACTION_FETCH_LIMIT, 'eyes');
  
  // プロンプトを表示（リアクション取得を待たない）
  const readlineInput = new ReadlineInput([], client, 'selection');
  
  // バックグラウンドでリアクションを取得して追加表示
  reactionsPromise.then(reactions => {
    // リアクションをマージして再表示（ユーザーが入力中でも）
  }).catch(error => {
    // エラーは無視（履歴だけでも使える）
  });
  
  // ユーザー入力を待つ
  const result = await readlineInput.prompt('チャンネル選択');
}
```

**メリット**:
- 起動時間が大幅に短縮（リアクション取得を待たない）
- ユーザーはすぐに履歴から選択できる
- リアクションは後から追加表示される

**デメリット**:
- リアクションが後から表示されるため、一瞬表示が変わる

---

### 提案2: リアクションキャッシュの導入 (推奨度: ★★★★☆)

**実装難易度**: 中
**効果**: 中
**リスク**: 低

リアクション情報をキャッシュし、起動時はキャッシュを使用。バックグラウンドで更新。

**実装方法**:
- リアクション専用のキャッシュクラスを作成
- TTL: 5分程度
- 起動時はキャッシュを表示、バックグラウンドでAPI取得して更新

**メリット**:
- 2回目以降の起動が高速
- キャッシュが新鮮なら、ほぼリアルタイム

**デメリット**:
- 初回起動は速くならない
- キャッシュ管理のコードが増える

---

### 提案3: リアクション表示の遅延読み込み (推奨度: ★★★☆☆)

**実装難易度**: 低
**効果**: 高
**リスク**: 中

起動時はリアクションを取得せず、ユーザーが`/r`コマンドを実行したときだけ取得。

**実装方法**:
```javascript
async function channelChat() {
  // 起動時はリアクションを取得しない
  const history = historyManager.getTodayHistory();
  
  // /rコマンド実行時のみリアクションを取得
  if (command === '/recent') {
    const reactions = await client.getReactions(...);
    // マージして表示
  }
}
```

**メリット**:
- 起動時間が最も短くなる
- リアクションを使わないユーザーには無駄な処理がない

**デメリット**:
- 起動時にリアクション履歴が表示されない
- UXが変わる（ユーザーが混乱する可能性）

---

### 提案4: API呼び出しのタイムアウト設定 (推奨度: ★★★★☆)

**実装難易度**: 低
**効果**: 低〜中
**リスク**: 低

リアクション取得に時間制限を設け、タイムアウト時は履歴のみ表示。

**実装方法**:
```javascript
const REACTION_TIMEOUT = 2000; // 2秒

async function channelChat() {
  const history = historyManager.getTodayHistory();
  
  try {
    const reactions = await Promise.race([
      client.getReactions(API.REACTION_FETCH_LIMIT, 'eyes'),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('timeout')), REACTION_TIMEOUT)
      )
    ]);
    // リアクションをマージ
  } catch (error) {
    // タイムアウトまたはエラー時は履歴のみ表示
    console.log(chalk.gray('💡 リアクション情報の取得に時間がかかっています...\n'));
  }
  
  // 履歴を表示
  await displayGroupedHistory(mergedHistory, client, historyManager);
}
```

**メリット**:
- ネットワークが遅い環境でも起動時間が保証される
- エラーハンドリングが改善される

**デメリット**:
- タイムアウト時はリアクションが表示されない

---

### 提案5: 履歴とリアクションの統合キャッシュ (推奨度: ★★☆☆☆)

**実装難易度**: 高
**効果**: 高
**リスク**: 中

履歴とリアクションをマージした状態でキャッシュし、起動時はそれを表示。

**メリット**:
- 起動が非常に高速
- 表示が一貫している

**デメリット**:
- 実装が複雑
- キャッシュの整合性管理が難しい

---

## 推奨する実装順序

### Phase 1: すぐに実装可能な改善 (推奨)
1. **提案1: リアクション取得の並列化**
   - 最も効果的で実装も簡単
   - 起動時間が体感で大幅に改善
   
2. **提案4: タイムアウト設定**
   - 提案1と組み合わせると最強
   - ネットワークが遅い環境でも安定

### Phase 2: さらなる改善
3. **提案2: リアクションキャッシュ**
   - 2回目以降の起動がさらに高速化
   - TTLを短めにすることでリアルタイム性を維持

---

## 実装後の期待値

### 現在
- 起動時間: 0.3秒 + リアクションAPI取得時間（環境により0.5〜2秒）
- 合計: **0.8〜2.5秒**

### Phase 1実装後
- 起動時間: 0.3秒（即座に履歴表示）
- リアクションは後から追加（0.5〜2秒後）
- **体感起動時間: 0.3秒**

### Phase 2実装後
- 起動時間: 0.3秒（キャッシュヒット時）
- **体感起動時間: 0.3秒（常に）**

---

## その他の最適化案

### 1. 依存モジュールの遅延読み込み
一部の大きなモジュールを遅延読み込みすることで初期起動を高速化。

### 2. 履歴ファイルの最適化
履歴ファイルのサイズが大きい場合、読み込みが遅くなる可能性。
- 定期的なクリーンアップ
- バイナリ形式での保存

### 3. Node.jsの起動最適化
- `NODE_OPTIONS=--max-old-space-size=512` で軽量化
- V8のスナップショット機能を活用（上級者向け）

---

## 結論

**最も効果的な改善策は「提案1: リアクション取得の並列化」です。**

理由:
- ✅ 実装が簡単（コード変更が少ない）
- ✅ 効果が大きい（起動時間が約2〜5倍高速化）
- ✅ リスクが低い（既存の動作を壊さない）
- ✅ ユーザー体験が向上（即座に操作可能）

この改善を実装しますか？
